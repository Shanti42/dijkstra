// public because PathNode is returned by PathFinder, so people will use it
// final because we don't want people to mess with it

// Caitlin

package dijkstra;


import java.util.Objects;
import java.util.Set;

/**
 * Represents a link along a path, containing a node and optionally the previous node on the path
 */
public final class PathNode implements Comparable<PathNode> {

    private final Node node;
    // TALK ABOUT: I don't think we need a "cost" here

    //Null previous denotes that this node is the original departure node
    private final PathNode previous;

    private PathNode(Node node, Cost cost, PathNode previous) {
        this.node = node;
        this.previous = previous;
    }

    /**
     *
     */
    public static final PathNode of(Node node, Cost cost, PathNode previous) {
        Objects.requireNonNull(node, "Received null node");
        Objects.requireNonNull(cost, "Received null getCost");
        //Previous node can be null, so no null check

        return new PathNode(node, cost, previous);
    }

    public static final PathNode of(Connection connection, PathNode previous) {
        Objects.requireNonNull(connection, "connection received null");

        return new PathNode(connection.getDestination(), connection.getCost(), previous);
    }

    public static final PathNode of(Node node) {
        Objects.requireNonNull(node, "received null node");

        return new PathNode(node, Cost.UNKNOWN, null);

    }

    public static final PathNode of(Node node, Cost cost) {
        Objects.requireNonNull(node, "received null node");

        return new PathNode(node, cost, null);

    }

    public Node getNode() {
        return node;
    }

    public Cost getCost() {
        return node.getNodeCost();
    }

    public Cost totalCost() {
        if (previous == null) {
            return this.getCost();
        }
        return getCost().plus(previous.totalCost());
    }

    public final PathNode getPrevious() {
        return previous;
    }

    final Set<Connection> availableConnections() {
        assert (isKnown());
        return node.availableConnections();
    }

    final Set<Connection> availableConnections(ConnectionType connectionType) {
        assert (isKnown());

        if (connectionType == null) {
            return availableConnections();
        }

        return node.availableConnections(getCost(), connectionType);
    }

    public final boolean isKnown() {
        return getCost().isKnown();
    }

    @Override
    public int compareTo(PathNode other) {
        Objects.requireNonNull(other, "PathNode, compareTo() -> Null parameter for other PathNode");
        Cost otherCost = other.getCost();
        if (this.getCost().equals(otherCost)) {
            return this.getNode().compareTo(other.getNode());
        } else {
            return this.getCost().compare(otherCost);
        }
    }

    /*
     * AUTO GENERATED BY INTELLIJ
     * */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PathNode pathNode = (PathNode) o;
        return node.equals(pathNode.node) &&
                Objects.equals(getCost(), pathNode.getCost()) &&
                Objects.equals(previous, pathNode.previous);
    }

    // for testing purposes
    @Override
    public String toString() {
        return node.getID();
    }

}
