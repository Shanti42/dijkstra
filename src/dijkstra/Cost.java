// Caitlin
// public because people will need to use this generic class to assign costs to edges, etc.
// final because people won't need to extend it/could mess it up if they do

package dijkstra;


import java.math.BigInteger;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Represents the cost of a Node or a Connection
 * @param <T> the object used to compute the value of the cost
 */
public final class Cost<T extends Addable> implements Comparable{
    private final static Logger LOGGER =
            Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);

    private T internalValue;

    public static final Cost<Addable> UNKNOWN = new Cost(null);
    public static final Cost<Addable> ZERO = new Cost(SimpleAddable.of(BigInteger.ZERO));

    private Cost(T object) {
        internalValue = object;
    }

    /**
     * Return a cost based on the input
     *
     * @param object an input of type Addable that this cost represents
     *
     * @throws NullPointerException if the input object is null
     */
    public static <T extends Addable> Cost<T> of(T object) {
        Objects.requireNonNull(object);
        return new Cost<T>(object);
    }


    /**
     * Returns true if route time is known, false otherwise
     *
     * @return a boolean representing if the internal value is known or not
     */
    public boolean isKnown() {
        return internalValue != null;
    }

    /**
     * Returns a cost based on private variables only
     *
     * @return the internal value of Cost
     */
    public T cost() {
        return internalValue;
    }


    /**
     * Adds the internal cost value to the input cost, and returns the result
     *
     * @param c the cost to be added
     *
     * @return the value of c plus the internal value of this Cost object
     *
     * @throws NullPointerException if the parameter c is null
     */
    public Cost plus(Cost c) {
        Objects.requireNonNull(c);

        return new Cost(internalValue.plus(c.cost()));
    }

    /**
     * Compares this object to an input. If that object is an instance of Cost, then it compares their
     * internal values.
     *
     * Unknown values always come after known values.
     *
     * @param other the object to compare
     */
    public int compareTo(Object other) {
        Objects.requireNonNull(other);
        if (other instanceof Cost) {
            int boolCompare = Boolean.compare(((Cost) other).isKnown(), isKnown());
            if (boolCompare != 0) {
                return boolCompare;
            }
            if (!isKnown())
                return 0;

            return internalValue.compareTo(((Cost) other).internalValue);
        } else {
            LOGGER.log(Level.SEVERE, "Cost.compareTo: input type invalid");
            throw new IllegalArgumentException("input's type is not correct");
        }
    }

    /* AUTOGENERATED BY INTELLIJ */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cost<?> cost = (Cost<?>) o;
        return Objects.equals(internalValue, cost.internalValue);
    }
}
